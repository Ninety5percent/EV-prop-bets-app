{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# app.py\n",
    "import streamlit as st\n",
    "import pandas as pd\n",
    "import numpy as np\n",
    "import requests\n",
    "from scipy.stats import norm\n",
    "import matplotlib.pyplot as plt\n",
    "import seaborn as sns\n",
    "import os\n",
    "from datetime import datetime\n",
    "import json\n",
    "import time\n",
    "from functools import lru_cache\n",
    "\n",
    "# --- CONFIG ---\n",
    "st.set_page_config(page_title=\"EV Prop Bets\", layout=\"wide\")\n",
    "sns.set(style=\"whitegrid\")\n",
    "\n",
    "# Secrets or env\n",
    "ODDS_API_KEY = st.secrets.get(\"ODDS_API_KEY\") or os.getenv(\"ODDS_API_KEY\")\n",
    "STATS_API_KEY = st.secrets.get(\"STATS_API_KEY\") or os.getenv(\"STATS_API_KEY\")\n",
    "\n",
    "if not ODDS_API_KEY or not STATS_API_KEY:\n",
    "    st.error(\"Set ODDS_API_KEY and STATS_API_KEY in Streamlit secrets or .env\")\n",
    "    st.stop()\n",
    "\n",
    "CACHE_FILE = \"streamlit_cache.json\"\n",
    "BETS_FILE = \"bets.csv\"\n",
    "REFRESH_MINUTES = 10\n",
    "\n",
    "# --- CACHING ---\n",
    "def load_cache():\n",
    "    if os.path.exists(CACHE_FILE):\n",
    "        with open(CACHE_FILE, \"r\") as f:\n",
    "            return json.load(f)\n",
    "    return {}\n",
    "\n",
    "def save_cache(data, key):\n",
    "    cache = load_cache()\n",
    "    cache[key] = data\n",
    "    cache[key][\"timestamp\"] = datetime.now().isoformat()\n",
    "    with open(CACHE_FILE, \"w\") as f:\n",
    "        json.dump(cache, f)\n",
    "\n",
    "# --- BET TRACKING FUNCTIONS ---\n",
    "def load_bets():\n",
    "    if os.path.exists(BETS_FILE):\n",
    "        df = pd.read_csv(BETS_FILE)\n",
    "        df['date'] = pd.to_datetime(df['date'])\n",
    "        return df\n",
    "    columns = [\"league\", \"player\", \"market\", \"side\", \"line\", \"odds\", \"stake\", \"date\", \"status\", \"actual_value\", \"profit\", \"notes\"]\n",
    "    return pd.DataFrame(columns=columns)\n",
    "\n",
    "def save_bets(df):\n",
    "    df.to_csv(BETS_FILE, index=False)\n",
    "\n",
    "def add_bet(row, stake, notes=\"\"):\n",
    "    df_bets = load_bets()\n",
    "    new_bet = {\n",
    "        \"league\": row[\"league\"],\n",
    "        \"player\": row[\"player\"],\n",
    "        \"market\": row[\"market\"],\n",
    "        \"side\": row[\"side\"],\n",
    "        \"line\": row[\"line\"],\n",
    "        \"odds\": row[\"odds\"],\n",
    "        \"stake\": stake,\n",
    "        \"date\": datetime.now(),\n",
    "        \"status\": \"Pending\",\n",
    "        \"actual_value\": np.nan,\n",
    "        \"profit\": 0.0,\n",
    "        \"notes\": notes\n",
    "    }\n",
    "    df_bets = pd.concat([df_bets, pd.DataFrame([new_bet])], ignore_index=True)\n",
    "    save_bets(df_bets)\n",
    "    return df_bets\n",
    "\n",
    "def update_bet(index, actual_value, notes):\n",
    "    df_bets = load_bets()\n",
    "    row = df_bets.iloc[index]\n",
    "    if pd.isna(actual_value):\n",
    "        return df_bets\n",
    "    # Determine win/loss\n",
    "    hit = (row[\"side\"] == \"Over\" and actual_value > row[\"line\"]) or (row[\"side\"] == \"Under\" and actual_value < row[\"line\"])\n",
    "    status = \"Win\" if hit else \"Loss\"\n",
    "    if row[\"odds\"] > 0:\n",
    "        payout = row[\"odds\"] / 100.0 + 1\n",
    "    else:\n",
    "        payout = 100.0 / abs(row[\"odds\"]) + 1\n",
    "    profit = row[\"stake\"] * (payout - 1) if hit else -row[\"stake\"]\n",
    "    df_bets.at[index, \"actual_value\"] = actual_value\n",
    "    df_bets.at[index, \"status\"] = status\n",
    "    df_bets.at[index, \"profit\"] = profit\n",
    "    df_bets.at[index, \"notes\"] = notes\n",
    "    save_bets(df_bets)\n",
    "    return df_bets\n",
    "\n",
    "def calculate_metrics(df_bets):\n",
    "    completed = df_bets[df_bets[\"status\"].isin([\"Win\", \"Loss\"])]\n",
    "    if completed.empty:\n",
    "        return {\"total_bets\": 0, \"win_rate\": 0, \"total_profit\": 0, \"roi\": 0}\n",
    "    total_bets = len(completed)\n",
    "    wins = len(completed[completed[\"status\"] == \"Win\"])\n",
    "    win_rate = wins / total_bets * 100 if total_bets > 0 else 0\n",
    "    total_profit = completed[\"profit\"].sum()\n",
    "    total_stake = completed[\"stake\"].sum()\n",
    "    roi = (total_profit / total_stake * 100) if total_stake > 0 else 0\n",
    "    return {\n",
    "        \"total_bets\": total_bets,\n",
    "        \"win_rate\": win_rate,\n",
    "        \"total_profit\": total_profit,\n",
    "        \"roi\": roi\n",
    "    }\n",
    "\n",
    "# --- LEAGUE CONFIG ---\n",
    "LEAGUE_CONFIG = {\n",
    "    \"nfl\": {\n",
    "        \"sport\": \"americanfootball_nfl\",\n",
    "        \"base_url\": \"https://api.sportsdata.io/v3/nfl\",\n",
    "        \"markets\": [\"player_pass_yards\", \"player_rush_yards\", \"player_rec_yards\"],\n",
    "        \"stat_map\": {\n",
    "            \"player_pass_yards\": \"PassingYards\",\n",
    "            \"player_rush_yards\": \"RushingYards\",\n",
    "            \"player_rec_yards\": \"ReceivingYards\"\n",
    "        },\n",
    "        \"pace_calc\": lambda df: (df['PassingAttempts'] + df['RushingAttempts']) / df['Games'],\n",
    "        \"def_calc\": lambda df: df['OpponentYards'] / df['Games'],\n",
    "    },\n",
    "    \"nba\": {\n",
    "        \"sport\": \"basketball_nba\",\n",
    "        \"base_url\": \"https://api.sportsdata.io/v3/nba\",\n",
    "        \"markets\": [\"player_points\", \"player_rebounds\", \"player_assists\"],\n",
    "        \"stat_map\": {\n",
    "            \"player_points\": \"Points\",\n",
    "            \"player_rebounds\": \"ReboundsTotal\",\n",
    "            \"player_assists\": \"Assists\"\n",
    "        },\n",
    "        \"pace_calc\": lambda df: (df['FieldGoalsAtt'] + 0.475 * df['FreeThrowsAtt'] + df['Turnovers']) / df['Games'],\n",
    "        \"def_calc\": lambda df: df['OpponentPoints'] / df['Games'],\n",
    "    }\n",
    "}\n",
    "\n",
    "# --- FETCHERS ---\n",
    "@lru_cache(maxsize=128)\n",
    "def fetch_current_season(base_url):\n",
    "    url = f\"{base_url}/scores/json/CurrentSeason?key={STATS_API_KEY}\"\n",
    "    return requests.get(url).json().strip('\"')\n",
    "\n",
    "@lru_cache(maxsize=128)\n",
    "def fetch_all_teams(base_url):\n",
    "    url = f\"{base_url}/scores/json/Teams?key={STATS_API_KEY}\"\n",
    "    return requests.get(url).json()\n",
    "\n",
    "@lru_cache(maxsize=128)\n",
    "def fetch_all_player_season_stats(base_url, season):\n",
    "    url = f\"{base_url}/stats/json/PlayerSeasonStats/{season}?key={STATS_API_KEY}\"\n",
    "    return requests.get(url).json()\n",
    "\n",
    "@lru_cache(maxsize=128)\n",
    "def fetch_all_player_game_stats(base_url, season):\n",
    "    url = f\"{base_url}/stats/json/PlayerGameStats/{season}?key={STATS_API_KEY}\"\n",
    "    return requests.get(url).json()\n",
    "\n",
    "@lru_cache(maxsize=128)\n",
    "def fetch_all_team_season_stats(base_url, season):\n",
    "    url = f\"{base_url}/stats/json/TeamSeasonStats/{season}?key={STATS_API_KEY}\"\n",
    "    return requests.get(url).json()\n",
    "\n",
    "@lru_cache(maxsize=128)\n",
    "def fetch_all_injuries(base_url, season):\n",
    "    url = f\"{base_url}/injuries/json/Injuries/{season}?key={STATS_API_KEY}\"\n",
    "    return requests.get(url).json()\n",
    "\n",
    "# --- BUILD LOOKUPS ---\n",
    "def build_lookup(config):\n",
    "    base_url = config[\"base_url\"]\n",
    "    cache_key = f\"{config['sport']}_lookup\"\n",
    "    cache = load_cache().get(cache_key, {})\n",
    "    if cache and (datetime.now().timestamp() - datetime.fromisoformat(cache[\"timestamp\"]).timestamp() < REFRESH_MINUTES * 60):\n",
    "        return cache[\"data\"]\n",
    "\n",
    "    with st.spinner(f\"Fetching {config['sport'].upper()} data...\"):\n",
    "        season = fetch_current_season(base_url)\n",
    "        teams = fetch_all_teams(base_url)\n",
    "        player_season = fetch_all_player_season_stats(base_url, season)\n",
    "        player_games = fetch_all_player_game_stats(base_url, season)\n",
    "        team_stats = fetch_all_team_season_stats(base_url, season)\n",
    "        injuries = fetch_all_injuries(base_url, season)\n",
    "\n",
    "    team_name_to_key = {t[\"Name\"]: t[\"Key\"] for t in teams}\n",
    "    df_team = pd.DataFrame(team_stats)\n",
    "    df_team['def_metric'] = config[\"def_calc\"](df_team)\n",
    "    df_team['opp_def_rank'] = df_team['def_metric'].rank(ascending=True)\n",
    "    df_team['team_pace'] = config[\"pace_calc\"](df_team)\n",
    "    team_def_rank = dict(zip(df_team['Key'], df_team['opp_def_rank']))\n",
    "    team_pace = dict(zip(df_team['Key'], df_team['team_pace']))\n",
    "\n",
    "    df_player = pd.DataFrame(player_season)\n",
    "    player_lookup = {}\n",
    "    for _, p in df_player.iterrows():\n",
    "        name = p[\"Name\"]\n",
    "        team = p[\"Team\"]\n",
    "        games = max(p.get(\"Games\", 1), 1)\n",
    "        stats = {k.replace(\"player_\", \"\"): p.get(v, 0) / games for k, v in config[\"stat_map\"].items()}\n",
    "        player_lookup[name] = {\n",
    "            \"team\": team,\n",
    "            \"season_avg\": stats,\n",
    "            \"recent_avg\": {k: stats[k] for k in stats}\n",
    "        }\n",
    "\n",
    "    if player_games:\n",
    "        df_games = pd.DataFrame(player_games)\n",
    "        if not df_games.empty:\n",
    "            df_games = df_games.sort_values(['PlayerID', 'GameDate'], ascending=[True, False])\n",
    "            recent = df_games.groupby('PlayerID').head(3).groupby('PlayerID').agg({\n",
    "                stat: 'mean' for stat in config[\"stat_map\"].values()\n",
    "            })\n",
    "            for pid, row in recent.iterrows():\n",
    "                name = next((p[\"Name\"] for p in player_season if p[\"PlayerID\"] == pid), None)\n",
    "                if name and name in player_lookup:\n",
    "                    stat_names = {v: k.replace(\"player_\", \"\") for k, v in config[\"stat_map\"].items()}\n",
    "                    player_lookup[name][\"recent_avg\"] = {\n",
    "                        stat_names.get(field, field): val for field, val in row.items()\n",
    "                    }\n",
    "\n",
    "    injury_factor = {\n",
    "        inj[\"Name\"]: 0.8 if inj.get(\"Status\") in [\"Out\", \"Questionable\"] else 1.0\n",
    "        for inj in injuries\n",
    "    }\n",
    "\n",
    "    lookup = {\n",
    "        \"season\": season,\n",
    "        \"team_name_to_key\": team_name_to_key,\n",
    "        \"team_def_rank\": team_def_rank,\n",
    "        \"team_pace\": team_pace,\n",
    "        \"player\": player_lookup,\n",
    "        \"injury_factor\": injury_factor,\n",
    "        \"stat_map\": config[\"stat_map\"]\n",
    "    }\n",
    "    save_cache({\"data\": lookup, \"timestamp\": datetime.now().isoformat()}, cache_key)\n",
    "    return lookup\n",
    "\n",
    "# --- FETCH ODDS ---\n",
    "def fetch_odds(sport, market):\n",
    "    url = f\"https://api.the-odds-api.com/v4/sports/{sport}/odds?apiKey={ODDS_API_KEY}&regions=us&markets={market}&oddsFormat=american\"\n",
    "    try:\n",
    "        resp = requests.get(url, timeout=10)\n",
    "        resp.raise_for_status()\n",
    "        return resp.json()\n",
    "    except:\n",
    "        return []\n",
    "\n",
    "# --- MAIN ---\n",
    "st.title(\"EV Player Prop Betting Dashboard\")\n",
    "st.markdown(\"### NFL + NBA | Real-Time +EV Bets | Bet Tracking\")\n",
    "\n",
    "# Tabs\n",
    "tab1, tab2 = st.tabs([\"Dashboard\", \"Bet Tracker\"])\n",
    "\n",
    "with tab1:\n",
    "    # Sidebar filters (for dashboard)\n",
    "    with st.sidebar:\n",
    "        st.header(\"Dashboard Filters\")\n",
    "        league_choice = st.selectbox(\"League\", [\"Both\", \"NFL\", \"NBA\"])\n",
    "        min_ev = st.slider(\"Min EV\", 0.0, 0.5, 0.05, 0.01)\n",
    "        player_search = st.text_input(\"Player Search\", \"\")\n",
    "        auto_refresh = st.checkbox(\"Auto-refresh every 10 min\", True)\n",
    "\n",
    "        if st.button(\"Refresh Now\"):\n",
    "            st.cache_data.clear()\n",
    "            st.rerun()\n",
    "\n",
    "    # Auto-refresh\n",
    "    if auto_refresh:\n",
    "        st.write(f\"Auto-refresh in {REFRESH_MINUTES} min\")\n",
    "        time.sleep(REFRESH_MINUTES * 60)\n",
    "        st.rerun()\n",
    "\n",
    "    # Run leagues\n",
    "    leagues_to_run = [\"nfl\", \"nba\"] if league_choice == \"Both\" else [league_choice.lower()]\n",
    "    all_bets = []\n",
    "\n",
    "    for league_key in leagues_to_run:\n",
    "        config = LEAGUE_CONFIG[league_key]\n",
    "        lookup = build_lookup(config)\n",
    "\n",
    "        odds_data = []\n",
    "        for market in config[\"markets\"]:\n",
    "            data = fetch_odds(config[\"sport\"], market)\n",
    "            for game in data:\n",
    "                home, away = game[\"home_team\"], game[\"away_team\"]\n",
    "                for book in game.get(\"bookmakers\", []):\n",
    "                    for m in book.get(\"markets\", []):\n",
    "                        if m[\"key\"] != market: continue\n",
    "                        desc = m.get(\"description\", \"\")\n",
    "                        player = \" \".join(desc.split()[:-2]) if \" \" in desc else desc.split()[0]\n",
    "                        for o in m.get(\"outcomes\", []):\n",
    "                            if o[\"name\"] not in [\"Over\", \"Under\"]: continue\n",
    "                            odds_data.append({\n",
    "                                \"player\": player,\n",
    "                                \"market\": market,\n",
    "                                \"home_team\": home,\n",
    "                                \"away_team\": away,\n",
    "                                \"line\": o.get(\"point\"),\n",
    "                                \"side\": o[\"name\"],\n",
    "                                \"odds\": o.get(\"price\"),\n",
    "                                \"bookmaker\": book[\"key\"],\n",
    "                                \"league\": league_key.upper()\n",
    "                            })\n",
    "\n",
    "        if not odds_data:\n",
    "            continue\n",
    "\n",
    "        df = pd.DataFrame(odds_data)\n",
    "        stat_map = lookup[\"stat_map\"]\n",
    "        market_key = lambda m: m.split(\"_\", 1)[1] if \"_\" in m else m\n",
    "\n",
    "        df[\"recent_avg\"] = df.apply(\n",
    "            lambda r: lookup[\"player\"].get(r[\"player\"], {}).get(\"recent_avg\", {}).get(market_key(r[\"market\"]), 0),\n",
    "            axis=1\n",
    "        )\n",
    "        df[\"season_avg\"] = df.apply(\n",
    "            lambda r: lookup[\"player\"].get(r[\"player\"], {}).get(\"season_avg\", {}).get(market_key(r[\"market\"]), 0),\n",
    "            axis=1\n",
    "        )\n",
    "\n",
    "        df[\"home_team_key\"] = df[\"home_team\"].map(lookup[\"team_name_to_key\"])\n",
    "        df[\"away_team_key\"] = df[\"away_team\"].map(lookup[\"team_name_to_key\"])\n",
    "        df[\"player_team_key\"] = df[\"player\"].map(lambda p: lookup[\"player\"].get(p, {}).get(\"team\"))\n",
    "        df[\"opp_team_key\"] = np.where(df[\"player_team_key\"] == df[\"home_team_key\"], df[\"away_team_key\"], df[\"home_team_key\"])\n",
    "\n",
    "        df[\"opp_def_rank\"] = df[\"opp_team_key\"].map(lookup[\"team_def_rank\"]).fillna(16)\n",
    "        df[\"team_pace\"] = df[\"player_team_key\"].map(lookup[\"team_pace\"]).fillna(70 if league_key==\"nba\" else 65)\n",
    "        df[\"injury_factor\"] = df[\"player\"].map(lookup[\"injury_factor\"]).fillna(1.0)\n",
    "        df[\"weather_factor\"] = 1.0\n",
    "\n",
    "        df[\"recent_avg\"] = df[\"recent_avg\"].fillna(df[\"season_avg\"])\n",
    "        df[\"season_avg\"] = df[\"season_avg\"].fillna(df[\"recent_avg\"])\n",
    "\n",
    "        scale = 3 if league_key == \"nba\" else 1\n",
    "        df[\"expected_value\"] = (\n",
    "            0.5 * df[\"recent_avg\"] +\n",
    "            0.2 * df[\"season_avg\"] -\n",
    "            0.1 * df[\"opp_def_rank\"] * scale +\n",
    "            0.2 * df[\"team_pace\"]\n",
    "        ) * df[\"injury_factor\"]\n",
    "\n",
    "        df[\"std_dev\"] = np.maximum(df[\"expected_value\"] * 0.2, 1)\n",
    "\n",
    "        df[\"prob_win\"] = df.apply(\n",
    "            lambda r: np.clip(\n",
    "                1 - norm.cdf(r[\"line\"], r[\"expected_value\"], r[\"std_dev\"]) if r[\"side\"] == \"Over\"\n",
    "                else norm.cdf(r[\"line\"], r[\"expected_value\"], r[\"std_dev\"]), 0, 1\n",
    "            ), axis=1\n",
    "        )\n",
    "\n",
    "        def implied_prob(odds):\n",
    "            return 100 / (odds + 100) if odds > 0 else abs(odds) / (abs(odds) + 100)\n",
    "\n",
    "        def ev_calc(p, odds):\n",
    "            payout = odds / 100.0 if odds > 0 else 100.0 / abs(odds)\n",
    "            return p * payout - (1 - p)\n",
    "\n",
    "        df[\"implied_prob\"] = df[\"odds\"].apply(implied_prob)\n",
    "        df[\"ev\"] = df.apply(lambda r: ev_calc(r[\"prob_win\"], r[\"odds\"]), axis=1)\n",
    "\n",
    "        df_best = df.sort_values([\"player\", \"market\", \"ev\"], ascending=[True, True, False]) \\\n",
    "                    .groupby([\"player\", \"market\"], as_index=False).first()\n",
    "\n",
    "        profitable = df_best[df_best[\"ev\"] > min_ev].copy()\n",
    "        if not profitable.empty:\n",
    "            all_bets.append(profitable)\n",
    "\n",
    "    if all_bets:\n",
    "        final_df = pd.concat(all_bets, ignore_index=True)\n",
    "        if player_search:\n",
    "            final_df = final_df[final_df[\"player\"].str.contains(player_search, case=False)]\n",
    "\n",
    "        final_df = final_df.round(4).sort_values(\"ev\", ascending=False)\n",
    "\n",
    "        # Display Dashboard\n",
    "        st.success(f\"Found {len(final_df)} +EV bets\")\n",
    "        col1, col2 = st.columns([3, 1])\n",
    "        with col1:\n",
    "            st.subheader(\"Top 10 +EV Bets\")\n",
    "            top10 = final_df.head(10)\n",
    "            fig, ax = plt.subplots(figsize=(10, 6))\n",
    "            sns.barplot(data=top10, y=\"player\", x=\"ev\", hue=\"league\", ax=ax)\n",
    "            ax.set_title(\"Top 10 +EV Player Props\")\n",
    "            st.pyplot(fig)\n",
    "\n",
    "        with col2:\n",
    "            st.download_button(\n",
    "                \"Download EV Bets CSV\",\n",
    "                final_df.to_csv(index=False),\n",
    "                \"ev_bets.csv\",\n",
    "                \"text/csv\"\n",
    "            )\n",
    "\n",
    "        st.dataframe(\n",
    "            final_df[[\"league\", \"player\", \"market\", \"side\", \"line\", \"odds\", \"prob_win\", \"implied_prob\", \"ev\"]],\n",
    "            use_container_width=True\n",
    "        )\n",
    "\n",
    "        # Bet Tracking Integration\n",
    "        st.subheader(\"Track Bets\")\n",
    "        selected_indices = st.multiselect(\n",
    "            \"Select bets to track (Player - Market)\",\n",
    "            final_df.index,\n",
    "            format_func=lambda i: f\"{final_df.at[i, 'player']} - {final_df.at[i, 'market']} ({final_df.at[i, 'side']} {final_df.at[i, 'line']})\"\n",
    "        )\n",
    "        stake = st.number_input(\"Stake Amount\", min_value=0.0, value=10.0)\n",
    "        notes = st.text_input(\"Notes (optional)\")\n",
    "        if st.button(\"Add Selected to Tracker\") and selected_indices:\n",
    "            for idx in selected_indices:\n",
    "                row = final_df.iloc[idx]\n",
    "                add_bet(row, stake, notes)\n",
    "            st.success(f\"Added {len(selected_indices)} bets to tracker!\")\n",
    "            st.rerun()\n",
    "    else:\n",
    "        st.info(\"No +EV bets found. Try lowering Min EV or checking later.\")\n",
    "\n",
    "with tab2:\n",
    "    st.header(\"Bet Tracker\")\n",
    "    df_bets = load_bets()\n",
    "\n",
    "    if df_bets.empty:\n",
    "        st.info(\"No bets tracked yet. Add from Dashboard.\")\n",
    "    else:\n",
    "        metrics = calculate_metrics(df_bets)\n",
    "        col_metrics = st.columns(4)\n",
    "        col_metrics[0].metric(\"Completed Bets\", metrics[\"total_bets\"])\n",
    "        col_metrics[1].metric(\"Win Rate\", f\"{metrics['win_rate']:.2f}%\")\n",
    "        col_metrics[2].metric(\"Total Profit\", f\"${metrics['total_profit']:.2f}\")\n",
    "        col_metrics[3].metric(\"ROI\", f\"{metrics['roi']:.2f}%\")\n",
    "\n",
    "        st.subheader(\"Tracked Bets\")\n",
    "        st.dataframe(\n",
    "            df_bets[[\"league\", \"player\", \"market\", \"side\", \"line\", \"odds\", \"stake\", \"date\", \"status\", \"profit\", \"notes\"]].sort_values(\"date\", ascending=False),\n",
    "            use_container_width=True\n",
    "        )\n",
    "\n",
    "        st.download_button(\n",
    "            \"Download Bets CSV\",\n",
    "            df_bets.to_csv(index=False),\n",
    "            \"tracked_bets.csv\",\n",
    "            \"text/csv\"\n",
    "        )\n",
    "\n",
    "    # Settle Bets\n",
    "    st.subheader(\"Settle Bets\")\n",
    "    pending = df_bets[df_bets[\"status\"] == \"Pending\"]\n",
    "    if not pending.empty:\n",
    "        bet_to_settle = st.selectbox(\n",
    "            \"Select Bet to Settle\",\n",
    "            pending.index,\n",
    "            format_func=lambda i: f\"{pending.at[i, 'player']} - {pending.at[i, 'market']} ({pending.at[i, 'side']} {pending.at[i, 'line']})\"\n",
    "        )\n",
    "        actual_value = st.number_input(\"Actual Value (e.g., yards/points)\", min_value=0.0)\n",
    "        notes_settle = st.text_input(\"Update Notes\")\n",
    "        if st.button(\"Settle Bet\"):\n",
    "            df_bets = update_bet(bet_to_settle, actual_value, notes_settle)\n",
    "            st.success(\"Bet settled!\")\n",
    "            st.rerun()\n",
    "    else:\n",
    "        st.info(\"No pending bets to settle.\")\n",
    "\n",
    "    # Manual Add Bet\n",
    "    st.subheader(\"Manual Add Bet\")\n",
    "    with st.form(\"manual_bet_form\"):\n",
    "        league_man = st.selectbox(\"League\", [\"NFL\", \"NBA\"])\n",
    "        player_man = st.text_input(\"Player\")\n",
    "        market_man = st.text_input(\"Market (e.g., player_points)\")\n",
    "        side_man = st.selectbox(\"Side\", [\"Over\", \"Under\"])\n",
    "        line_man = st.number_input(\"Line\", min_value=0.0)\n",
    "        odds_man = st.number_input(\"Odds\", value=-110)\n",
    "        stake_man = st.number_input(\"Stake\", min_value=0.0, value=10.0)\n",
    "        notes_man = st.text_input(\"Notes\")\n",
    "        submit = st.form_submit_button(\"Add Manual Bet\")\n",
    "        if submit:\n",
    "            manual_row = pd.Series({\n",
    "                \"league\": league_man,\n",
    "                \"player\": player_man,\n",
    "                \"market\": market_man,\n",
    "                \"side\": side_man,\n",
    "                \"line\": line_man,\n",
    "                \"odds\": odds_man,\n",
    "            })\n",
    "            add_bet(manual_row, stake_man, notes_man)\n",
    "            st.success(\"Manual bet added!\")\n",
    "            st.rerun()"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.11.0"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
